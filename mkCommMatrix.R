#!/usr/bin/env Rscript

library(lattice) # for levelplot
options(digits=3)

cleardiag = 1    # remove diagnoal?
every = 5        # every x thread IDs
scale = every/2  # font size
printnum = 0     # print cell values?

comm_het = function(frame) {
	if (length(frame) < 8)
	    return(0)
	frame = frame / max(frame, na.rm=T) * 100
	# frame[frame>30] = 100
	return(mean(apply(frame, 1, var, na.rm=T)))
}

comm_avg = function(frame)
	return(sum(as.numeric(unlist(frame)))/length(frame)/length(frame))

lambda = function(l) {return((max(l)/mean(l)-1)*100)}

myPanel = function(x, y, z, ...) {
	panel.levelplot(x,y,z,...)
	if (printnum) {
		panel.abline(h=c(1:(nt-1))+0.5, v=c(1:(nt-1))+0.5)
		panel.text(x, y, round(z,1),cex=scale)
	}
}

args = commandArgs(trailingOnly=TRUE)

if (length(args) < 1)
	stop("Usage: mkCommMatrix.R <CommPattern.csv>...\n")

for (filename in args) {

	if (grepl(".csv", filename)) {
		outfilename = gsub(".csv", ".pdf", filename)
		if (filename == outfilename)
			outfilename = paste(filename, ".pdf", sep="")

		csv = as.data.frame(read.csv(filename, header=FALSE))
	} else if (grepl(".dat", filename)) { # .dat files generated by eztrace
		outfilename = gsub(".dat", ".pdf", filename)
		outcsvname = gsub(".dat", ".csv", filename)
		if (filename == outfilename)
			outfilename = paste(filename, ".pdf", sep="")

		csv = data.matrix(read.table(filename, header=FALSE))
		csv = csv + t(csv) # make csv symmetric
		csv = apply(csv, 2, rev) # reverse csv
		csv = data.frame(csv)
		write.table(csv, file=outcsvname, sep=",", col.names=F, row.names=F)
	}

	nt = ncol(csv)

	rownames(csv) = rev(as.integer(rownames(csv)) - 1)
	colnames(csv) = rev(rownames(csv))

	mat = data.matrix(csv)
	mat = t(mat[nrow(mat):1,])

	private = 0
	comm = 0

	for (i in 1:nt)
		for (j in 1:nt)
			if (i!=j) comm = comm + mat[i,j]
			else private = private + mat[i,j]


	if (cleardiag==1)
		for (i in 1:nt)
			mat[i,i] = 0

	het = comm_het(mat)
	cavg = comm_avg(mat)

	optlist=list(cex=scale,limits=range(-0.5:nt+1),labels=seq(0,nt-1,every),tck=c(1,0),at=seq(1,nt,every))

	# generate comm matrix
	pdf(outfilename, family="NimbusSan", width=nt, height=nt)
	print(levelplot(mat, panel=myPanel, col.regions=grey(seq(1,0,-0.01)), colorkey=F, xlab=NULL, ylab=NULL, scales=list(x=optlist, y=optlist)))
	garbage = dev.off()

	embedFonts(outfilename)
	system(paste("pdfcrop ", outfilename, outfilename, "> /dev/null"))


	# remove lower part of the matrix
	for (i in 1:nt) {
		if (i<nt/2)
			for (j in 1:i)
				mat[i,j] = 0
		else
			for (j in i:nt)
				mat[i,j] = 0
	}

	mat = matrix(rowSums(mat))
	mat = mat/max(mat) * 100
	l = lambda(mat)
	outfilename = gsub(".pdf", ".load.pdf", outfilename)

	# generate comm balance
	pdf(outfilename, family="NimbusSan", width=nt, height=nt)
	print(levelplot(mat, panel=myPanel, col.regions=grey(seq(1,0,-0.01)), colorkey=F, xlab=NULL, ylab=NULL, scales=list(x=optlist,y=list(labels=NULL,tck=c(0,0)))))
	garbage = dev.off()

	embedFonts(outfilename)

	system(paste("pdfcrop ", outfilename, outfilename, "> /dev/null"))

	cat("Generated", outfilename, " hetero:", het, "\tavg:", cavg, "\tlambda:", l, "\tcomm_ratio:", comm/private *100, "%\n")
}
